// Copyright (c) 2023 Nick Piaddo
// SPDX-License-Identifier: Apache-2.0 OR MIT

// From dependency library

// From standard library
use std::ffi::CString;
use std::fmt;
use std::str::FromStr;

// From this library
use crate::core::errors::ParserError;

/// Tag names supported by `libmount`.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[non_exhaustive]
pub enum TagName {
    /// Human readable file system identifier.
    Label,
    /// File system universally unique identifier.
    Uuid,
    /// Human readable partition identifier.
    PartLabel,
    /// Partition universally unique identifier.
    PartUuid,
    /// Hardware block device ID as generated by `udevd`.
    Id,
}

impl TagName {
    /// View this `TagName` as a UTF-8 `str`.
    pub fn as_str(&self) -> &str {
        match self {
            TagName::Label => "LABEL",
            TagName::Uuid => "UUID",
            TagName::PartLabel => "PARTLABEL",
            TagName::PartUuid => "PARTUUID",
            TagName::Id => "ID",
        }
    }

    /// Converts this `TagName` to a [`CString`].
    pub fn to_c_string(&self) -> CString {
        // FileSystem's string representation does not contain NULL characters,  we can safely
        // unwrap the new CString.
        CString::new(self.as_str()).unwrap()
    }
}

impl fmt::Display for TagName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl AsRef<TagName> for TagName {
    #[inline]
    fn as_ref(&self) -> &TagName {
        self
    }
}

impl FromStr for TagName {
    type Err = ParserError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.trim().to_uppercase().as_str() {
            "LABEL" => Ok(TagName::Label),
            "UUID" => Ok(TagName::Uuid),
            "PARTLABEL" => Ok(TagName::PartLabel),
            "PARTUUID" => Ok(TagName::PartUuid),
            "ID" => Ok(TagName::Id),
            _otherwise => {
                let err_msg = format!("invalid tag name: {:?}", s);

                Err(ParserError::TagName(err_msg))
            }
        }
    }
}

#[cfg(test)]
#[allow(unused_imports)]
mod tests {
    use super::*;
    use pretty_assertions::{assert_eq, assert_ne};

    #[test]
    #[should_panic(expected = "invalid tag name")]
    fn tag_name_can_not_parse_empty_string() {
        let _: TagName = "".parse().unwrap();
    }

    #[test]
    #[should_panic(expected = "invalid tag name")]
    fn tag_name_can_not_parse_invalid_string() {
        let _: TagName = "DUMMY".parse().unwrap();
    }

    #[test]
    fn tag_name_can_parse_label_lowercase() -> crate::Result<()> {
        let actual: TagName = "label".parse()?;
        let expected = TagName::Label;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_label_uppercase() -> crate::Result<()> {
        let actual: TagName = "LABEL".parse()?;
        let expected = TagName::Label;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_uuid_lowercase() -> crate::Result<()> {
        let actual: TagName = "uuid".parse()?;
        let expected = TagName::Uuid;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_uuid_uppercase() -> crate::Result<()> {
        let actual: TagName = "UUID".parse()?;
        let expected = TagName::Uuid;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_partlabel_lowercase() -> crate::Result<()> {
        let actual: TagName = "partlabel".parse()?;
        let expected = TagName::PartLabel;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_partlabel_uppercase() -> crate::Result<()> {
        let actual: TagName = "PARTLABEL".parse()?;
        let expected = TagName::PartLabel;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_partuuid_lowercase() -> crate::Result<()> {
        let actual: TagName = "partuuid".parse()?;
        let expected = TagName::PartUuid;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_partuuid_uppercase() -> crate::Result<()> {
        let actual: TagName = "PARTUUID".parse()?;
        let expected = TagName::PartUuid;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_id_lowercase() -> crate::Result<()> {
        let actual: TagName = "id".parse()?;
        let expected = TagName::Id;

        assert_eq!(actual, expected);

        Ok(())
    }

    #[test]
    fn tag_name_can_parse_id_uppercase() -> crate::Result<()> {
        let actual: TagName = "ID".parse()?;
        let expected = TagName::Id;

        assert_eq!(actual, expected);

        Ok(())
    }
}
