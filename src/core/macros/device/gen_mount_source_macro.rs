// Copyright (c) 2023 Nick Piaddo
// SPDX-License-Identifier: Apache-2.0 OR MIT

#[allow(unused_macros)]
#[macro_export]
#[doc(hidden)]
macro_rules! gen_mount_source {
    ($type_name:ident, $module:literal, $test_prefix:literal) => {
        paste::paste!{

            // From dependency library

            // From standard library
            use std::fmt;
            use std::str::FromStr;

            // From this library
            use $crate::core::device::BlockDevice;
            use $crate::core::device::MountPoint;
            use $crate::core::device::NFS;
            use $crate::core::device::Pseudo;
            use $crate::core::device::SmbFs;
            use $crate::core::device::SshFs;
            use $crate::core::device::Tag;
            use $crate::core::errors::ParserError;

            /// Source of a device to mount.
            ///
            /// A source can take any of the following forms:
            /// - a block device path (e.g. `/dev/sda1`),
            /// - a network ID:
            ///     - Samba: `smb://ip-address-or-hostname/shared-dir`,
            ///     - NFS: `hostname:/shared-dir`  (e.g. knuth.cwi.nl:/dir)
            ///     - SSHFS: `[user@]ip-address-or-hostname:[/shared-dir]` elements in brackets are optional (e.g.
            ///     tux@192.168.0.1:/share)
            /// - a tag:
            ///     - `UUID=uuid` (file system UUID),
            ///     - `LABEL=label` (human readable file system identifier),
            ///     - `PARTLABEL=label` (human readable partition identifier),
            ///     - `PARTUUID=uuid` (partition UUID),
            ///     - `ID=id` (hardware block device ID as generated by `udevd`).
            /// - `none` for pseudo-filesystems.
            ///
            /// (For more information, see the subsection titled [Indicating the device and
            /// filesystem](https://www.man7.org/linux/man-pages/man8/mount.8.html) of the `mount`
            /// syscall)
            ///
            /// # Examples
            ///
            /// ```
            /// # use pretty_assertions::assert_eq;
            /// use rsmount::core::device::BlockDevice;
            /// use rsmount::core::device::MountPoint;
            /// use rsmount::core::device::NFS;
            /// use rsmount::core::device::Pseudo;
            /// use rsmount::core::device::SmbFs;
            /// use rsmount::core::device::SshFs;
            /// use rsmount::core::device::Tag;
            #[doc = concat!("use rsmount::", $module, "::", stringify!($type_name), ";")]
            ///
            /// fn main() -> rsmount::Result<()> {
            ///    let samba_share: SmbFs = "smb://samba.server.internal/shared".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(samba_share);")]
            ///    assert!(source.is_samba_share());
            ///
            ///    let sshfs_share: SshFs = "tux@sshfs.server.internal:/shared".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(sshfs_share);")]
            ///    assert!(source.is_sshfs_share());
            ///
            ///    let block_device: BlockDevice = "/dev/vda".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(block_device);")]
            ///    assert!(source.is_block_device());
            ///
            ///    let mount_point: MountPoint = "/boot".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(mount_point);")]
            ///    assert!(source.is_mount_point());
            ///
            ///    let tag: Tag = "UUID=dd476616-1ce4-415e-9dbd-8c2fa8f42f0f".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(tag);")]
            ///    assert!(source.is_tag());
            ///    assert!(source.is_tag_uuid());
            ///
            ///    let none: Pseudo = "none".parse()?;
            #[doc = concat!("    let source = ", stringify!($type_name), "::from(none);")]
            ///    assert!(source.is_pseudo_fs());
            ///
            ///    Ok(())
            /// }
            /// ```
            #[derive(Debug, Eq, PartialEq)]
            #[non_exhaustive]
            pub enum $type_name {
                BlockDevice(BlockDevice),
                MountPoint(MountPoint),
                NFS(NFS),
                SmbFs(SmbFs),
                SshFs(SshFs),
                Tag(Tag),
                PseudoFs(Pseudo),
            }

            impl $type_name {
                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a block device.")]
                pub fn is_block_device(&self) -> bool {
                    matches!(self, Self::BlockDevice(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a mount point.")]
                pub fn is_mount_point(&self) -> bool {
                    matches!(self, Self::MountPoint(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is an NFS share address.")]
                pub fn is_nfs_share(&self) -> bool {
                    matches!(self, Self::NFS(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a SmbFs share address.")]
                pub fn is_samba_share(&self) -> bool {
                    matches!(self, Self::SmbFs(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is an SSHFS address.")]
                pub fn is_sshfs_share(&self) -> bool {
                    matches!(self, Self::SshFs(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a tag (e.g `UUID=uuid`, `LABEL=label`,")]
                /// `PARTUUID=uuid`, etc.).
                pub fn is_tag(&self) -> bool {
                    matches!(self, Self::Tag(_))
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a pseudo-filesystem.")]
                pub fn is_pseudo_fs(&self) -> bool {
                    matches!(self, Self::PseudoFs(_))
                }


                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a `LABEL=label` tag.")]
                pub fn is_tag_label(&self) -> bool {
                    matches!(self, Self::Tag(t) if t.is_label())
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a `PARTLABEL=label` tag.")]
                pub fn is_tag_partition_label(&self) -> bool {
                    matches!(self, Self::Tag(t) if t.is_partition_label())
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a `UUID=uuid` tag.")]
                pub fn is_tag_uuid(&self) -> bool {
                    matches!(self, Self::Tag(t) if t.is_uuid())
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is a `PARTUUID=uuid` tag.")]
                pub fn is_tag_partition_uuid(&self) -> bool {
                    matches!(self, Self::Tag(t) if t.is_partition_uuid())
                }

                #[doc = concat!("Returns `true` if this `", stringify!($type_name), "` is an `ID=id` tag.")]
                pub fn is_tag_id(&self) -> bool {
                    matches!(self, Self::Tag(t) if t.is_id())
                }
            }

            impl AsRef<$type_name> for $type_name {
                #[inline]
                fn as_ref(&self) -> &$type_name {
                    self
                }
            }

            impl TryFrom<&str> for $type_name {
                type Error = ParserError;

                fn try_from(s: &str) -> Result<Self, Self::Error> {
                    // Parse string into matching type...
                    Tag::from_str(s)
                        .map(Self::from)
                        .or_else(|_| Pseudo::from_str(s).map(Self::from))
                        .or_else(|_| SmbFs::from_str(s).map(Self::from))
                        .or_else(|_| SshFs::from_str(s).map(Self::from))
                        .or_else(|_| NFS::from_str(s).map(Self::from))
                        .or_else(|_| MountPoint::from_str(s).map(Self::from))
                        // ...if all else fails, assume `s` is a block device.
                        .or_else(|_| BlockDevice::from_str(s).map(Self::from))
                }
            }

            impl TryFrom<String> for $type_name {
                type Error = ParserError;

                #[inline]
                fn try_from(s: String) -> Result<Self, Self::Error> {
                    Self::try_from(s.as_str())
                }
            }

            impl TryFrom<&String> for $type_name {
                type Error = ParserError;

                #[inline]
                fn try_from(s: &String) -> Result<Self, Self::Error> {
                    Self::try_from(s.as_str())
                }
            }

            impl FromStr for $type_name {
                type Err = ParserError;

                fn from_str(s: &str) -> Result<Self, Self::Err> {
                    Self::try_from(s)
                }
            }

            impl fmt::Display for $type_name {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let output = match self {
                        Self::BlockDevice(device) => device.to_string(),
                        Self::MountPoint(mount_point) => mount_point.to_string(),
                        Self::NFS(share) => share.to_string(),
                        Self::SmbFs(share) => share.to_string(),
                        Self::SshFs(share) => share.to_string(),
                        Self::Tag(tag) => tag.to_string(),
                        Self::PseudoFs(fs) => fs.to_string(),
                    };

                    write!(f, "{}", output)
                }
            }

            impl From<BlockDevice> for $type_name {
                #[inline]
                fn from(device: BlockDevice) -> $type_name {
                    $type_name::BlockDevice(device)
                }
            }

            impl From<MountPoint> for $type_name {
                #[inline]
                fn from(mount_point: MountPoint) -> $type_name {
                    $type_name::MountPoint(mount_point)
                }
            }

            impl From<NFS> for $type_name {
                #[inline]
                fn from(share: NFS) -> $type_name {
                    $type_name::NFS(share)
                }
            }

            impl From<SmbFs> for $type_name {
                #[inline]
                fn from(share: SmbFs) -> $type_name {
                    $type_name::SmbFs(share)
                }
            }

            impl From<SshFs> for $type_name {
                #[inline]
                fn from(share: SshFs) -> $type_name {
                    $type_name::SshFs(share)
                }
            }

            impl From<Tag> for $type_name {
                #[inline]
                fn from(share: Tag) -> $type_name {
                    $type_name::Tag(share)
                }
            }

            impl From<Pseudo> for $type_name {
                #[inline]
                fn from(fs: Pseudo) -> $type_name {
                    $type_name::PseudoFs(fs)
                }
            }

            #[cfg(test)]
            #[allow(unused_imports)]
            mod tests {
                use super::*;
                use pretty_assertions::{assert_eq, assert_ne};

                #[test]
                #[should_panic(expected = "expected a device path instead of")]
                fn [<$test_prefix _does_not_parse_an_empty_string_as_a_block_device>]() {
                    let source = "";
                    let _ = $type_name::try_from(source).unwrap();
                }

                #[test]
                fn [<$test_prefix _parses_a_block_device>]() -> $crate::Result<()> {
                    let source = "/dev/vda";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_block_device());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_mount_point>]() -> $crate::Result<()> {
                    let source = "/boot";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_mount_point());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_nfs_share_address_as_an_sshfs_share>]() -> $crate::Result<()> {
                    let source = "localhost:/share";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_sshfs_share());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_samba_share_address>]() -> $crate::Result<()> {
                    let source = "smb://localhost/share";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_samba_share());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_sshfs_share_address>]() -> $crate::Result<()> {
                    let source = "user@localhost:/share";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_sshfs_share());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_uuid_tag>]() -> $crate::Result<()> {
                    let source = "UUID=dd476616-1ce4-415e-9dbd-8c2fa8f42f0f";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_tag_uuid());

                    Ok(())
                }

                #[test]
                fn [<$test_prefix _parses_a_pseudo_fs>]() -> $crate::Result<()> {
                    let source = "none";
                    let actual: $type_name = source.parse()?;

                    assert!(actual.is_pseudo_fs());

                    Ok(())
                }
            }
        } //---- END paste
    };
}
